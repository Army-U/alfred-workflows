#!/usr/bin/env ruby

require 'json'
require 'open-uri'
require 'pathname'

# Helpers
def get_env(env_variable:, default:, as_bool: false, make_pathname: false)
  to_bool = lambda { |value|
    case value
    when true, 'true', 'yes', 1, '1' then true
    when false, 'false', 'no', 0, '0', nil, '' then false
    else raise ArgumentError, "Invalid value: #{value.inspect}"
    end
  }

  if env_variable.nil? || env_variable.empty?
    return to_bool.call(env_variable) if as_bool
    return Pathname.new(default).expand_path if make_pathname
    return default
  end

  return to_bool.call(env_variable) if as_bool
  return Pathname.new(env_variable).expand_path if make_pathname
  env_variable
end

# Constants
Ignored_layouts = %w[art_series double_faced_token token vanguard]
Multi_faced_layout = %w[modal_dfc transform]
Rarity_order = %w[mythic rare uncommon common]

Sort_by_rarity = get_env(
  env_variable: ENV['mtg_sort_by_rarity'],
  default: false,
  as_bool: true
)

Cards_json = Pathname.new(ENV['mtg_cards_json'])
Pathname.new(ENV['alfred_workflow_cache']).mkpath

All_cards_info = lambda {
  data_url = JSON.parse(URI('https://api.scryfall.com/bulk-data/oracle-cards').read)['download_uri']
  data = JSON.parse(URI(data_url).read)

  Sort_by_rarity ? data.sort_by { |card_info| Rarity_order.index(card_info['rarity']) } : data
}.call


script_filter_items = []

All_cards_info.each do |card_info|
  next if Ignored_layouts.any? { |layout| card_info['layout'] == layout }

  if Multi_faced_layout.any? { |layout| card_info['layout'] == layout }
    card = card_info['card_faces'][0] # If card is doube-faced, use info of first face
    card['scryfall_uri'] = card_info['scryfall_uri']
  else
    card = card_info
  end

  list =
    if card['mana_cost'].empty? && card['type_line'] =~ /.*Land.*/
      'Lands'
    elsif card['colors'].empty?
      'Colorless'
    elsif card['colors'].length > 1
      'Multi'
    elsif card['colors'].first == 'W'
      'White'
    elsif card['colors'].first == 'U'
      'Blue'
    elsif card['colors'].first == 'B'
      'Black'
    elsif card['colors'].first == 'R'
      'Red'
    elsif card['colors'].first == 'G'
      'Green'
    end

  pt = card['power'].nil? ? '' : " 𐄁 #{card['power']}/#{card['toughness']}"
  rulings = card['oracle_text'].nil? || card['oracle_text'].empty? ? '' : " 𐄁 #{card['oracle_text'].gsub("\n", '. ')}"
  image_size = ENV['mtg_image_size'] =~ /(png|large|normal|small)/ ? ENV['mtg_image_size'] : 'png'
  image = card['image_uris'][image_size]

  script_filter_items.push(
    title: card['name'],
    autocomplete: card['name'],
    subtitle: "#{card['mana_cost']} (#{card['cmc'].to_i}) 𐄁 #{card['type_line']}#{pt} 𐄁 #{card['rarity']}#{rulings}",
    quicklookurl: image,
    icon: { path: 'mtg_symbols/' + list + '.png' },
    arg: card['name'] + '|' + card['scryfall_uri'].sub('?utm_source=api', '')
  )
end

Cards_json.write({ items: script_filter_items }.to_json)
